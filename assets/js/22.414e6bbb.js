(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{275:function(n,e,t){"use strict";t.r(e);var a=t(0),s=Object(a.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h3",{attrs:{id:"对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#对象"}},[n._v("#")]),n._v(" 对象")]),n._v(" "),t("h4",{attrs:{id:"工厂模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#工厂模式"}},[n._v("#")]),n._v(" 工厂模式")]),n._v(" "),t("div",{staticClass:"language-创建对象模式 extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('    function createPerson(name,age,job){\n    var o = new Object ();\n    o.name = name;\n    o.age  = age;\n    o.job  = job;\n    o.sayName = function () {\n    alert(this.name);\n    }\n    return o; \n    }\n\n    var person1 =  createPerson("jack", 20,"student");\n    var person2 =  createPerson("john", 21,"teacher");\n    person1.sayName();      //jack\n    person2.sayName();      //john\n    alert(typeof person1);  //function Object() { [native code] }\n    alert(person2.constructor); //undefined\n   工厂模式问题，没有解决对象识别问题，（即怎样知道一个对象的类型)\n')])])]),n._v(" "),t("h4",{attrs:{id:"构造函数模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#构造函数模式"}},[n._v("#")]),n._v(" 构造函数模式")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('    function Person(name,age,job){\n        this.name = name;\n        this.age  = age;\n        this.job  = job;\n        this.sayName = function () {\n            alert(this.name);\n        } \n    }\n\n    var person1 =  new Person("jack", 20,"student");\n    var person2 =  new Person("john", 21,"teacher");\n    person1.sayName();      //jack\n    person2.sayName();      //john\n    console.log(typeof person1);  //object\n    console.log(typeof person2); //object\n    console.log(person1.sayName == person1.sayName) //true\n    构造函数模式和工厂模式相比较，优点就是将实例标示为一种特定的类型(object)，构造函数的问题就是每个方法都在每一个实例上重新定义一次\n')])])]),t("h4",{attrs:{id:"原型模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原型模式"}},[n._v("#")]),n._v(" 原型模式")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('    function Person(){\n    }\n\n    Person.prototype.name = "Jack";\n    Person.prototype.age = 21;\n    Person.prototype.job = "teacher";\n    Person.prototype.sayName = function(){\n        console.log(this.name);\n    };\n    var person1 = new Person();\n    var person2 = new Person();\n    person1.sayName(); //Jack\n    person2.sayName(); //Jack\n    console.log(person1.sayName == person1.sayName); //true\n    //原型对象的问题，由其共享本质所导致的\n')])])]),t("blockquote",[t("ol",[t("li",[n._v("原型是一个需要被重点理解的点，每一个函数可以被看成一个对象，它有一个"),t("code",[n._v("prototype")]),n._v(" 属性，指向函数的原型对象，在默认情况下，所有原型对象会获得一个"),t("code",[n._v("constructor")]),n._v("属性指向"),t("code",[n._v("prototype")]),n._v("所在那个函数，而对于每一个实例，则有一个"),t("code",[n._v("_proto_")]),n._v("属性，指向函数原型对象要明确一点，这个连接**"),t("code",[n._v("存在于实例和构造函数的原型对象")]),n._v("**之间，"),t("em",[n._v("而不是存在于实例与构造函数之间")]),n._v("。\n"),t("img",{attrs:{src:"http://omla9ld8j.bkt.clouddn.com/$1JL%7B2%28YM5SS%5B0P5IU%25$Q%5DW.png",alt:"原型链图解"}})])])]),n._v(" "),t("ol",{attrs:{start:"2"}},[t("li",[n._v("当为对象实例添加一个同名属性时，则会屏蔽原型链上的属性或方法")]),n._v(" "),t("li",[t("code",[n._v("getOwnPropertyNames(Object)")]),n._v("和"),t("code",[n._v("Object.keys(Object)")])])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('    function Person() {}\n    Person.prototype.sayHi = function() {};\n    Person.prototype.weight = 120;\n    var p1 = new Person();\n    p1.name = "jack";\n    p1.age = 12;\n    Object.keys(p1); //["name","age"]; 所有可枚举\n    Object.getOwnPropertyNames(Person.prototype); //["constructor",sayHi","sayHi"] 所有属性(包括函数名)\n\n    //更简单的原型语法\n    function Person() {\n    }\n    Person.prototype = {\n        name : "Jack",\n        age  : 21,\n        job  : "teacher",\n        sayName : function () {\n        }\n    }; //对象字面量写法\n    写法确实简洁，方便，但是使用对象字面量创建的原型方法，会改写原来的指针， 具体来说， 原来`constructor`指向`prototype`所在的函数，但是现在重写之后，指向`Object`\n')])])]),t("h4",{attrs:{id:"组合使用构造函数模式和原型模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组合使用构造函数模式和原型模式"}},[n._v("#")]),n._v(" 组合使用构造函数模式和原型模式")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('    function Person(name,age,job) {\n        this.name = name;\n        this.age  = age;\n        this.job  = job;\n        this.friends = ["tom","alice"];\n    }\n    Person.prototype = {\n        constructor : Person,\n        sayName : function () {\n            alert(this.name);\n        }\n    }; //对象字面量写法\n    var person1 = new Person("jack", 20,"student");\n    var person2 = new Person("john", 21,"teacher");\n    person1.friends.push("bob");\n    alert(person1.friends);\n    alert(person2.friends);\n    alert(person1.friends === person2.friends);\n    alert(person1.sayName === person2.sayName);\n')])])]),t("h4",{attrs:{id:"寄生构造函数模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#寄生构造函数模式"}},[n._v("#")]),n._v(" 寄生构造函数模式")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('    function Person(name,age,job){\n        var o = new Object ();\n        o.name = name;\n        o.age  = age;\n        o.job  = job;\n        o.sayName = function () {\n            alert(this.name);\n        }\n        return o; \n     }\n    var person1 =  new Person("jack", 20,"student");\n    var person2 =  new Person("john", 21,"teacher");\n    person1.sayName();      //jack\n    person2.sayName();      //john\n    alert(typeof person1);  //object\n    alert(typeof person2); //object\n    alert(person1 instanceof Person);  //false true\n    alert(person2 instanceof Person); //false  true    \n    跟工厂模式没什么区别，这里只是用 new 来创建对象，而之前就是通过函数返回对象来调用方法\n')])])]),t("h3",{attrs:{id:"继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[n._v("#")]),n._v(" 继承")]),n._v(" "),t("h4",{attrs:{id:"原型链实现继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原型链实现继承"}},[n._v("#")]),n._v(" 原型链实现继承")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("    function SuperType() {\n      this.property = true;\n    }\n    SuperType.prototype.getSuperValue = function (){\n        return this.property;\n    }\n    function SubType() {\n        this.subProperty= false;\n    }\n    SubType.prototype = new SuperType();\n    SubType.prototype.getSubValue = function(){\n    return this.subProperty;\n    }\n    var instance = new SubType();\n    alert(instance.getSuperValue());\n    alert(instance.getSubValue());\n")])])]),t("h4",{attrs:{id:"借用构造函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#借用构造函数"}},[n._v("#")]),n._v(" 借用构造函数")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('    function SuperType() {\n        this.colors=["blue","black","white"];\n    }\n\n    function SubType () {\n        SuperType.call(this);\n    }\n\n    var instance1 = new SubType();\n    instance1.colors.push("grenn");\n    alert(instance1.colors);\n\n    var instance2 = new SubType();\n    alert(instance2.colors);\n')])])]),t("h4",{attrs:{id:"组合继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#组合继承"}},[n._v("#")]),n._v(" 组合继承")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('    function SuperType(name) {\n        this.name = name; //父类属性，子类都有副本\n        this.colors = ["red","blue","green"];\n    }\n\n    SuperType.prototype.sayName = function () {\n        alert(this.name); //父类原型方法\n    };\n\n    function SubType(name,age){\n        SuperType.call(this,name); //调用父类构造函数\n        this.age = age;\n        console.log(this);\n    }\n    SubType.prototype = new SuperType();\n    SubType.prototype.constructor = SubType();\n    SubType.prototype.sayAge = function () {\n    alert(this.age);\n    }\n    var instance1 = new SubType("Jack",26);\n    instance1.colors.push("white");\n    alert(instance1.colors);\n    instance1.sayName();\n    instance1.sayAge();\n\n    var instance2 = new SubType("Bob", 45);\n    alert(instance1.colors);\n    instance1.sayName();\n    instance1.sayAge();\n')])])]),t("h4",{attrs:{id:"原型式继承"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原型式继承"}},[n._v("#")]),n._v(" 原型式继承")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("    function object(o) {\n        function F() {}\n        F.prototype = o;\n        return new F();\n    }\n")])])]),t("h3",{attrs:{id:"prototype和-proto-的区别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#prototype和-proto-的区别"}},[n._v("#")]),n._v(" "),t("code",[n._v("prototype和_proto_的区别")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("    function Point(x, y) {\n      this.x = x;\n      this.y = y;\n    }\n    var myPoint = new Point();\n    // the following are all true\n    myPoint.__proto__ == Point.prototype\n    myPoint.__proto__.__proto__ == Object.prototype\n    myPoint instanceof Point;\n    myPoint instanceof Object;\n\n    `_proto_`在每一个对象或者对象的原型上都存在，而`prototype`只存在于构造函数中，或者说函数中，`_proto_`都是指向他们的**“构造函数的原型”**比如上面的 `myPoint.__proto__ == Point.prototype` 和 `myPoint.__proto__.__proto__ == Object.prototype` 以及`myPoint._proto_ = Function.prototype`\n\n")])])]),t("h3",{attrs:{id:"js中的this和apply、call"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#js中的this和apply、call"}},[n._v("#")]),n._v(" "),t("code",[n._v("js中的this和apply、call")])]),n._v(" "),t("blockquote",[t("p",[n._v("在平常的学习过程中，对js中的this和apply、call认识比较模糊，通过查阅一些资料来加强认识。\n"),t("code",[n._v("js 中 this 和 apply、call的理解，平常我们对this在一些面向对象的语言中，都有一些认识，在Java语言里一般会在构造函数里边使用")])])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("    public class Person {\n        private String name;\n        private String sex;\n        private int age;\n        public Person(String name,String sex,int age){\n            this.name = name;\n            this.sex  = sex;\n            this.age  = age;\n        }\n    .........\n    }\n")])])]),t("blockquote",[t("p",[n._v("在js里面this 和 面向对象的 this 还是有一些差别，重点在于js里的this指针受到的影响较大，具体来说就是三个方面，"),t("strong",[n._v("在全局环境中，this指向window全局变量，这里window对象其实也是系统实例化的一个对象，只是不需要我们手动去new，javascript里call和apply操作符可以随意改变this指向，这看起来很灵活，但是这种不合常理的做法破坏了我们理解this指针的本意，同时也让写代码时候很难理解this的真正指向，javascript里的函数是一个高阶函数，编程语言里的高阶函数是可以作为对象传递的，同时javascript里的函数还有可以作为构造函数，这个构造函数可以创建实例化对象，结果导致方法执行时候this指针的指向会不断发生变化，很难控制")]),n._v("而且js不是纯面向对象的语言，毕竟还是解释性语言，我们可以借助面向对象语言的认识来理解，但是javascript里的this在没有进行new操作也会生效，这时候this往往会指向全局对象window。")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('    var name = "huahaitao";\n    console.log(name); //huahaitao\n    console.log(this.name); //huahaitao\n    console.log(this); //huahaitao\n')])])]),t("blockquote",[t("p",[n._v("在js里面对象字面量的写法和 new Object()一样，会改变this 的指向,这里要说明一点，在一般情况下，谁被 new，this就指向它。在js高程里面有如下定义，new操作符会让构造函数产生如下变化：")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("    1. 创建一个新对象；\n    2. 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）；\n    3. 执行构造函数中的代码（为这个新对象添加属性）；\n    4. 返回新对象\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('    var obj = {\n        name : "huahaitao",\n        sex  : "male",\n        age  : 22,\n        show: function(){\n            console.log(this.name+"  "+this.sex+"   "+this.age);\n            console.log(this);\n        }\n    };\n    var Otherobj = new Object();\n    Otherobj.name = "huahaitao";\n    Otherobj.sex  = "male";\n    Otherobj.age  = 22;\n    Otherobj.show = function(){\n            console.log(this.name+"  "+this.sex+"   "+this.age);\n            console.log(this);\n    };\n    obj.show(); //huahaitao male 22    Object()\n    Otherobj.show(); //huahaitao male 22    Object()\n')])])]),t("blockquote",[t("p",[n._v("js 里面的apply和call是如何改变this的，还有一点就是apply和call传入参数的不同，apply() 方法在指定 this 值和参数（参数以数组或类数组对象的形式存在）的情况下调用某个函数，即fun.call(this,[arg1,arg2])，call()方法call() 方法在指定 this 值和参数（参数以参数列表的形式存在）的情况下调用某个函数，即fun.call(this,arg1,arg2).")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('    var name = "huahaitao";\n    function test(name){\n        console.log(name);\n        console.log(this.name);\n        console.log(this);\n    }\n    var obj = {\n        name: "Alice"\n    }\n    test(); // undefined huahaitao window\n    test.call(obj,"Bob"); // Bob Alice Object 这里this指向改变了\n    test.apply(obj,["Alex"]); //Alex Alice Object 这里this指向改变了\n\n')])])]),t("blockquote",[t("p",[n._v("字面表示法在简单的表示里我们很容易知道this指向对象本身，但是这个对象会有方法，方法的参数可能会是函数，而这个函数的定义里也可能会使用this指针，如果传入的函数没有被实例化过和被实例化过，this的指向是不同，有时我们还想在传入函数里通过this指向外部函数或者指向被定义对象本身，这些乱七八糟的情况使用交织在一起导致this变得很复杂，结果就变得糊里糊涂。")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[n._v("1. 传入的参数是函数的别名，那么函数的this就是指向window；\n2. 传入的参数是被new过的构造函数，那么this就是指向实例化的对象本身；\n3. 如果我们想把被传入的函数对象里this的指针指向外部字面量定义的对象，那么我们就是用apply和call\n")])])]),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('    var name = "I am window";\n    var obj = {\n        name : "huahaitao",\n        fun1 : function(obj){  //传入参数是被new 过的构造函数\n            obj.show();\n        },\n        fun2 : function(fun){    //传入参数是函数的别名\n            fun();\n        },\n        fun3 : function(fun){   //使用call\n            fun.call(this,"test");\n        }\n    }\n\n    function Person(name){\n        this.name = name;\n        this.show = function(){\n            console.log(name);\n            console.log(this.name);\n            console.log(this);\n        }\n    }\n    function test(){\n        console.log(name);\n        console.log(this.name);\n        console.log(this);\n    }\n    function test1(name){\n        console.log(name);\n        console.log(this.name);\n        console.log(this);\n    }\n    var p = new Person("Alice");\n    obj.fun1(p); //Alice Alice Object\n    obj.fun2(test); //I am window  I am window  window\n    obj.fun3(test1); //test huahaitao object\n')])])]),t("h3",{attrs:{id:"json语法，解析json，序列化json"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#json语法，解析json，序列化json"}},[n._v("#")]),n._v(" "),t("code",[n._v("JSON语法，解析JSON，序列化JSON")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v('    1. JSON的语法可以表示以下三种类型的值，**常量 对象 数组**，不支持变量，函数或对象实例.\n    2. 与JavaScript对象字面量相比，JSON对象有两个地方不一样，没有声明变量和末尾的分号，对象的属性必须加上双引号.\n    3. 解析和序列化方法，`stringify()和 parse()`.\n    //函数的参数，第一个是传进去的对象，第二个是过滤器，可以是数组或者函数，第三个是格式，\n    //可以是字符串或者数字，为了json数据格式更好地展示\n    stringify(obj,[],[string | number]) \n    var obj = {\n    "name" : "hht",\n    "age"  : 12,\n    "sex"  : "male"\n    }   \n    var json = JSON.stringify(obj,["name"],5);\n    console.log(json);\n    /*{\n           "name": "hht"\n    }*/\n    var test = JSON.parse(json);  \n    console.log(test); //Object {name: "hht"}   __proto__ : Object\n    \n    //使用函数过滤\n    var json = JSON.stringify(obj,function(key,value){\n    switch(key){\n    case "name" : return null;\n    case "age"  : return value*3;\n    case "sex"  : return undefined\n    default :\n    return value;\n    }\n    });\n    console.log(json); // {"name":null,"age":36}\n    var test = JSON.parse(json);  \n    console.log(test); //Object {name:null, age:36}   __proto__ : Object\n    \n    //parse()\n    var obj = JSON.parse(json,function(key,value){});\n')])])]),t("h3",{attrs:{id:"原型继承的几种写法比较"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#原型继承的几种写法比较"}},[n._v("#")]),n._v(" "),t("code",[n._v("原型继承的几种写法比较")])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("//方式一    对象字面量的方式改变了 constructor的指向 ，指向object ，相当于 new object()  \n   var Calculator1 = function (decimalDigits, tax) {\n        this.decimalDigits = decimalDigits;\n        this.tax = tax;\n    };\n    Calculator1.prototype = {\n        add: function (x, y) {\n        return x + y;\n        },\n        subtract: function (x, y) {\n            return x - y;\n        }\n    };\n    console.log(Calculator1 instanceof Object);\n    var cal = new Calculator1();\n    console.log(cal.constructor, cal._proto_);\n    console.log(Calculator1.prototype.constructor);\n    console.log((new Calculator1()).add(1, 3));\n    \n    //方式二    这种方式有助于封装函数\n    Calculator2.prototype = function () {\n            add = function (x, y) {\n                return x + y;\n            },\n\n            subtract = function (x, y) {\n                return x - y;\n            }\n            return {\n                add: add,\n                subtract: subtract\n            }\n        } ();\n\n       \n    //方式三    一条一条的添加，不推荐这种写法\n    var Calculator3 = function (decimalDigits, tax) {\n    this.decimalDigits = decimalDigits;\n    this.tax = tax;\n    };\n    Calculator.prototype.add = function (x, y) {\n        return x + y;\n    };\n\n    Calculator.prototype.subtract = function (x, y) {\n        return x - y;\n    };\n")])])]),t("h3",{attrs:{id:"bind方法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#bind方法"}},[n._v("#")]),n._v(" "),t("code",[n._v("bind方法")])]),n._v(" "),t("blockquote",[t("p",[n._v("参考 "),t("a",{attrs:{href:"https://www.smashingmagazine.com/2014/01/understanding-javascript-function-prototype-bind/",target:"_blank",rel:"noopener noreferrer"}},[n._v("bind"),t("OutboundLink")],1)])]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("var myObj = {\n    specialFunction: function () {\n    },\n    anotherSpecialFunction: function () {\n    },\n    getAsyncData: function (cb) {\n        cb();\n    },\n    render: function () {\n        var that = this;\n        this.getAsyncData(function () {\n            that.specialFunction();\n            that.anotherSpecialFunction();\n        });\n    }\n};\nmyObj.render();\n//Uncaught TypeError: Object [object global] has no method 'specialFunction\n改写一下\nrender: function () {\n    this.getAsyncData(function () {\n        this.specialFunction();\n        this.anotherSpecialFunction();\n    }.bind(this));\n    \n")])])])])}),[],!1,null,null,null);e.default=s.exports}}]);